---
title: 'Development approach I use to simplify my development'
publishedAt: '2022-11-27'
summary: 'Development approach I use to simplify my development'
url: 'classes-and-approaches-i-use-to-simplify-my-development'
category: 'technology'
image: '/assets/pngs/Blog/technology/2022/11/2022-11-27-classes-and-approaches-i-use-to-simplify-my-development-01.png'
---

How many times did you see the next class?

```java
public interface UserService {
  User findUsers(String username);
  List<Book> findBooks(String username, int year);
  List<Article> findArticles(String username, String author);
  List<VeryCustomObject> findBy(
    String username,
      String attribute1,
      String attribute2,
      String attribute3
  );
}
```

I saw a lot. Sure, not 4 methods, but probably 100+ methods. I personally find it not readable and there is room for human error in the following cases:

1/ Code review. Easy to miss when somebody misplaced **username** and **attribute1** as method parameters\
2/ Refactoring. Sometimes you have crappy tests or no tests at all. Even when you start a simple refactoring you could shoot yourself in the leg. Your goal is for all methods to have a **username** as the first parameter and it is very easy to lose 1-2 methods in a big project in the process.

How do I start looking for this problem? I decided that big help will be to have a compilation check to know that at least one parameter is in the correct place. I decided to have a <u>UsernameV1</u> class. The major point is to **use immutable classes**.

<figure>
  ```java
  // Lombok
  @Data
  public class UsernameV1 {
    private final String identifier;

    public static Username of(String identifier) {
      return new Username(identifier);
    }
  }
  ```
  <figcaption>How it started – version №1</figcaption>
</figure>

After this small change, I had a better way to know that refactoring is a little bit easier to start. I will have a compilation error if the username parameter will be misplaced

```java
public interface UserService {
  User findUsers(Username username);
  List<Book> findBooks(Username username, int year);
  List<Article> findArticles(Username username, String author);
  List<VeryCustomObject> findBy(
    Username username,
      String attribute1,
      String attribute2,
      String attribute3
  );
}
```

The next thing is crappy JSON responses that even I didn't like. So let's say we have a Book class that we use for responses

```java
// Lombok
@Data
public class Book {
  private final UsernameV1 username;
  private final String author;
  private final String title;
}
```

So deserialized JSON will be

```java
{
  "username": {
    "identifier": "tech1"
  },
  "author": "Erich Maria Remarque",
  "title": "All Quiet on the Western Front"
}
```

Do you like it? Yeah, me neither. In a lot of places in my front-end application I must go through a lot of messy spaghetti code to add something like this

```java
const response = await userService.getBookById(bookId)
const book = response.data

# WAS
# const username = book.username

const username = book.username.identifier # <--
```

Not very efficient to have a small advantage on the server side but a lot of problems on the front end. And I am not even talking about cases when you need to send proper JSON structure to the server for the book creation process. So what did I do?

<figure>
  ```java
  // Lombok
  @Getter
  @EqualsAndHashCode
  public class Username {
    // [1] — serialization annotation
    @JsonValue
    private final String identifier;

    // [2] — deserialization annotation
    @JsonCreator
    public Username(String identifier) {
      this.identifier = identifier;
    }

    public static Username of(String identifier) {
      return new Username(identifier);
    }

    // [3] — readable logging-based value
    @Override
    public String toString() {
      return this.identifier;
    }
  }
  ```
  <figcaption>How it ended – version #2</figcaption>
</figure>

[1] — @JsonValue is a way to instead of the previous crappy book JSON response I could have the next structure:

```java
{
  "username": "tech1",
  "author": "Erich Maria Remarque",
  "title": "All Quiet on the Western Front"
}
```

[2] — @JsonCreator is a way to deserialize book JSON when you pass it to the server

[3] — Do you want to have readable logs? Feel the difference 

```java
10:03:44.160 [main] Start synchronization process for user `UsernameV1(identifier=tech1)`
// VS.
10:03:44.151 [main] Start synchronization process for user `tech1`
```

The main points that I like about this approach:

1/ No changes in front-end code. It's expensive to change something so big when the project contains 50k+ lines of the code

2/ Compilation fail-safe on the backend. And much more readability. I really enjoy my V2 method approach.

```java
public interface AuthenticationService {
  void authenticateV1(String username, String password);
  void authenticateV2(Username username, Password password);
}
```

More examples on [GitHub](https://github.com/tech1-io/tech1-framework?ref=yyluchkiv.com). Please don't hesitate to star this repo. We will appreciate it a lot.

<Image
  alt={ 'Username meme' }
  src={ '/assets/pngs/Blog/technology/2022/11/2022-11-27-classes-and-approaches-i-use-to-simplify-my-development-01.png' }
  width={ 900 }
  height={ 650 }
/>
